:imagesdir: images
:sectnum-start: 2


== Chapter two - The structure

In this chapter we describe the structure or anatomy of ALA without delving too much into the hows and whys, which are covered in later chapters.

The organisation of this chapter (and all chapters) is different perspectives. We all have different prior knowledge on which we build new knowledge, so we each have a different way to understand new things. Use the section whose perspective makes the most sense to you. Because of the use of perspectives, there will sometimes be repetition of ideas across sections. 


=== Software elements, relations among them

In this first perspective, we describe ALA in the context of one of the definitions of software architecture, "software elements and the relations among them". Indeed the first two fundamental constraints of ALA define what elements are and what their permisable relations are.

In this section, we also use an example code that lets us explain the concepts in a concrete way right down to the C# executable level. We show all the code in all the layers. 

==== The only unit of code is an abstraction

The only unit of code in ALA is an abstraction. Not module, not class, not function. An abstraction is more than a module, class or function in that it must be a 'generalized conceptual idea'. It's what our brains use to understand the world, not what compilers use. It must be learnable as a concept. Many modules, classes or functions in traditional code are not be good abstractions, especially if they are an integral part of a specific system with have associations with peer modules, classes or functions.

Abstraction goes hand in hand with reuse. Krueger said that abstraction and reuse are two sides of the same coin. Abstractions tend to be stable - as stable as their conceptual idea. When we have a dependency on an abstraction, it is a dependency only on that conceptual idea.

Here is an example domain. The abstraction works on a stream of data. It smooths the data and slow its down the rate. It has an input and an output dataflow port: 

.DomainAbstractions\LowPassFilter.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary> <6>
    /// ALA Domain abstraction. 
    /// Has one DataFlow input port and one DataFlow output port, both type double.
    /// Smooths the incoming data and outputs it at a lower frequency.
    /// The strength parameter sets the degree of filtering 
    /// (cutoff frequency relative to input frequency).
    /// and also sets the lower rate of output.
    /// e.g. if Strength is set to 10, then there is one output for every 10 input
    /// datas received.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    
    class LowPassFilter : IDataFlow<double> // input port <1>
    {
        public LowPassFilter(int strength, double initialOutput = 0.0) <3>
        {
            this.strength = strength;
            this.lastOutput = initialState;
        }

        private IDataFlow<double> output;  // output port <2>

        private int strength;
        private double lastOutput = 0.0; <4>
        private int resampleCounter = 0; <4>

        void IDataFlow<double>.Push(double data) <5>
        {
            lastOutput = (data + strength * lastOutput) / (strength+1);
            if (resampleCounter==0)
            {
                resampleCounter += strength;
                output?.Push(lastOutput);
            }
            resampleCounter--;
        }
    }
}
....



<1> The input port, the implemented interface

<2> The output port, simple private field of type interface
+
The input port is the IDataFlow<double> interface that is implemented by the class. Dataflow is a programming paradigm which is a stream of data without end. Incoming data arrives via the Push method in this interface. We never know where the data comes from. The output port is the private field named "output". This field will be set pointing at an IDataFlow<double> input of an instance of another abstraction somewhere. We never know where the data goes to. How the _output_ field gets set is described later.
+
Because the abstraction uses ports, it has no knowledge of other peer abstractions. If it did, it would not be an abstraction. It is self-understandable at design-time, except for the even more abstract concepts on which it depends. In this case that is DataFlow and the concept of Wiring, which will wire instances of this abstraction to instances of other abstractions with compatible ports. These are described more fully shortly.

<3> The public interface is only used by the layer above. It is only for creating and configuring instances of the abstraction. The abstraction has two configurations parameters. One is optional. Optional configurations can also be implemented with setters.

<4> The abstraction keeps some internal state. This goes somewhat contrary to functional programming where we want all state to be passed in. In ALA a good abstraction trumps being stateless. As an abstraction that is naturally stateful, a filter should hide its state internally.  

<5> The implementation of the input interface does the work of the filter. Note that port interfaces are always implemented explicitly. (If implemented implicitly, they would be part of the public API of the class, which we don't wan't. We only want the port accessed via the interface.)

<6> When an abstraction is created, it is critically important to add comments that make it learnable by explaining the concept it provides, its ports, its configurations and an example of its use. In Visual Studio, I copy these comments before the constructor because that allows them to pop up in the IDE when hovering on the constructor name where instances are created with a _new_ keyword.

In ALA, abstractions are implemented as files. The name of the file is the name of the abstraction. The file typically contains a class, but may contain more than one class, enums, delegates, interfaces etc. I usually put the implementation of the public configuration interface first, then the ports that are implemented as fields, then any other internal state, then the implementations of the ports.  

Internally, abstractions are cohesive (which means sticking together) or highly interconnected code collaborating for a single purpose. Because it's cohesive code, ALA does not prescribe any internal organisation for abstractions. We do not care about dependencies or any inter-relationships inside an abstraction. Any part of the code may need knowledge of any other part to understand. In fact the more cohesive everything is the better, as long as it is small.

Abstractions are the only mechanism that provides design-time _information hiding_. When David Parnas coined the term _information hiding_ he meant at _design-time_. Unfortunately there is a popular meme that _information hiding_ means _encapsulation_. The same idea of design-time information hiding has other names such as Alistair Cockburn's _protected variations_, and Robert Martin's version of the OCP (open closed principle). 

A module or class can encapsulate information at compile-time but does not necessarily hide information at design-time. In the case of our LowPassFilter, the quality of being a good abstraction means that its internals are not coupled or collaborating with other modules. It's bounded by its conceptual idea. If it were a module instead, it might primarily perform the filter function for a specific application, but knowing which application it is part of would cause it to take on ancilliary functions, such as  offset and scale to output the units needed by the application. Or it might grab its input knowing where it comes from. Or it might send it's output to a specific place, or even to multiple specific places using direct method calls. It might connect to the application's settings menu for its settings. All these things would cause design-time coupling through the application.


===== Meaning of abstraction

Unfortunately, there are now two distinct meanings for the meme 'higher level of abstraction' in common usage in software engineering. We need to take a moment to understand the difference. In ALA, abstraction means the original dictionary meaning:

****
Etymology: abstract literally means _draw away_ [a common idea or concept from specific examples]

Miriam Webster: relating to or involving general ideas or qualities rather than specific people, objects or actions.
****

The other meaning of 'higher level of abstraction' used in the software engineering community appears to be 'further away from the domain of the computer and closer to the problem domain'. For example, layers are often shown building up from the hardware. They can also build up from the database, or a physical communication medium, such as the layers of the OSI communications model. In this meaning, the application is considered the most abstract. For example, a 3-tier system or a communication stack uses this type of layering. The perception is that because we no longer have to deal with computer domain details such as data storage, communications protocols, hardware, etc, we must be more abstract. The problem with this is that the problem domain also deals with details. These details come from the real world and are described by detailed requirements. The modules that contain these details are no more abstract than those in the various domains of computing.

Conventional layering tends to use this second meaning of 'abstract' and layers are said to be more abstract as you go up. ALA layers get more abstract as you go down.

The layers are not the same either. To convert conventional layers to ALA, you generally just tip them on their side so that they are not layers but independent disconnected abstractions. Each of them knows about details of something but they no longer directly connect to each other in either direction. On their own they will do nothing. The layer above, whose job is to know the details of a specific application or system, composes instances of them by instantiating them, configuring them, and wiring them together using compositional abstractions in a lower layer.

A final thought about abstraction is to compare it with the SRP (single responsibility principle). The SRP is not really the best way to think about abstractions. It is better to think about what details an abstraction implementation knows about. It can be a specific user story, a specific feature, a type of UI element, a type of database, a protocol, a hardware device, etc. It will contain all the cohesive knowledge about that thing. In doing so, it may have multiple responsibilities. For example an abstraction that knows about a protocol or a hardware device may have responsibility for both input and output. It may have responsibility for configuring the hardware device. A filter abstraction may both smooth the input data and resample the to a lower rate at the output, because resampling is cohesive with smoothing. 



==== Abstraction internal structure

Internally an abstraction is cohesive. This means that every line of code is related to, and collaborates with, every other line of code to implement the idea of the abstraction. It has no internal structure imposed by ALA. It is essentially a small ball of mud.

We shouldn't think of an abstraction implementation as being a _composition_ of _elements_ such as functions, variables, structs, methods, enums, delegates, statements, lines of code or the like because they are all collaborating. They are all just syntactical components, but not semantic components. In other words, they don't have meaning on their own related to the concept of the abstraction. Only when we take all of lines of code together do we have meaning. So we never semantically break an abstraction implementation into smaller parts. 

The external structure and internal structure with respect to abstractions are at opposite extremes. One is zero coupled and constrained only to the use of instances of lower layer abstractions and the other is fully coupled and highly cohesive.

That there is no structure in an abstraction's implementation is important because in conventional architectures we are used to hierarchical encapsulation. In ALA their is strictly no containment nesting. Instead there is only abstraction layers. 




==== ALA uses only one relationship type

This is the second of the three fundamental constraints. ALA uses a single type of relationship - a dependency on an abstraction that is more abstract than the one whose implementation uses it.

[plantuml,file="diagram-05a.png"]
----
@startdot
digraph foo {
// size="3!"
subgraph cluster_1
{
label="Abstraction A"
labeljust=l
labelloc=b
style=rounded 
A [ style = invis ];
}
B [label="Abstraction\nconcept B"; shape = rect; style=rounded ]
A -> B  [dir="both", arrowhead="open", arrowtail="tee", color=green, label=" requires knowledge of to understand"]
}
@enddot
----

In terms of our previous example, LowPassFilter is Abstraction A and IDataFlow is Abstraction concept B.

Notice how in the diagram the relationship arrow comes from inside A. This is significant. It is the code that implements A that requires knowledge of abstraction concept B. We never actually draw lines when using abstractions, so you wont see this type of line in ALA diagrams. We only use it here while describing this one type of relationship that we are allowed. 

B must be more abstract than A. "More abstract" means more general, not specific to A, and have a greater scope of reuse than A.

Because B is more abstract, it is more stable. ALA therefore automatically enforces the Stable Dependencies Principle. 

The relationship means that, to read and understand the code inside A, you must know the abstraction concept B - not how the insides of abstraction B work. The word "abstraction" implies that it should be learnable in a short time and easy to retain. When we learn an abstraction concept, there is a moment when we suddenly 'get it', a small moment of insight. 

Here are some more legal dependencies, this time in text form. They are from a user story in the application layer to the domain abstractions layer.

.Application\Thermometer.cs
[source,C#]
....
    new AnalogInput(channel: 2)
    .WireIn(new LowPassFilter(strength: 10))
    .WireIn(new OffsetAndScale(offset: -31, scale: 0.2))
    .WireIn(new Display(label: "Temperature"));
....

Legal dependencies from a _Thermometer_ user story abstraction on abstractions _AnalogInput_, _LowPassFilter_, _OffsetAndScale_, _Display_ and _WireIn_. The user story takes input from an analog to digital converter, filters them to remove noise, scales them to be in degrees, and displays them.

Because of the way our brains have evolved to understand a complex world in terms of abstractions, abstractions are the only mechanism that hide knowledge at design-time. Dependencies on more abstract abstractions have zero coupling between the code using the abstraction and the code implementing the abstraction.

Dependencies on more abstract abstractions also explicitly tell us what knowledge we need in order to _understand_ code. For example, if abstraction A is __thermometer__ and abstraction B is __display__, then to understand the code that implements the thermometer requires knowledge of the concept of display. That's why we sometimes refer to it as a knowledge dependency. Such a dependency always applies at design-time, and may apply at compile-time and run-time. Some knowledge dependencies may apply at design-time only. For example a dependency may be on a convention, or it may be simply the knowledge of ALA. You need knowledge of those things to fully understand the code. We want to be explicit and clear about knowledge dependencies for every bit of code inside every abstraction, so we endeavour to always state implicit dependencies in comments. For example, in the implementation of an abstraction for a hardware device, I include a reference to the datasheet.

Architectures generally work by applying constraints that restrict the infinite variety of ways code could be organised. The ALA constraint of this single relationship type may seem severe at first, but after some practice they change from a hinderence to being increasingly helpful in guiding the design. Sometimes the abstractions come easily from the wording in the requirements and sometimes they require sustained inventive thought processes, especially in a new domain. 

If you are finding it difficult, then first make sure you have well written requirements that capture all details. The user story abstractions should be just a more formal expression of them in terms of abstractions they probably already mention. 

In most domains, I usually start with the UI description in the requirements as they most readily reveal their domain abstractions. Then it becomes apparent that dataflows must be connected to these instances of UI abstraction elements. Data transformation and state abstractions will then become apparent next. 


===== RIP the UML class diagram

All UML relationships except one are illegal in ALA, and that one is restricted to being a composition on a more abstract class or interface. Such a relationship is always represented in code by just referring to the abstraction by its name. For example, you wouldn't use a library abstraction such as _regex_ by drawing a line on a diagram to a box representing the regex class. You would just use the regex abstraction by name. 

Furthermore, such a use of an abstraction by name is inside the class. It's part of the class's internal implementation. It makes no sense to show the relationship at the zoomed out scale outside the class with a filled diamond line coming from the border.

So, if a UML class diagram were drawn of an ALA application, there would be no lines at all, just boxes in space arranged in layers. This makes sense, because classes are used to implement abstractions, and abstractions have zero coupling with one another. 

image::ALAClassDiagram.drawio.png[ALAClassDiagram.drawio.png, title="UML class diagrams for ALA have no relation lines.", width=90%, link=ALAClassDiagram.drawio.png]

The diagram is not useful. We will never use it again. That's not to say we won't use diagrams. Diagrams can be used in ALA to represent the internals of an abstraction. This is often done in the layer representing the application for a feature or user story. In ALA terms, it shows instances of (lower layer) abstractions composed together as a graph. In implementation terms it is a (static) UML object diagram.

Class diagrams are evil. They have done more damage to software architecture than any other meme. Following are the UML relationships you cannot use in ALA, and what you do instead.

* *Association*: A conventional program will typically have many bad dependencies referred to as _associations_ in the UML. Most are there because data, messages, events, execution flow, etc, need to get from one place to another in the program. They are illegal in ALA. So how can a program work without them? How do we get data and events from one place to another at run-time? The short answer is that all these associations become a simple line of code inside an abstraction in the layer above. Such lines are not relationships or dependencies - they are contained inside a single abstraction, no different to a line of code that say calls one function and passes the result to another function. In ALA, you create objects in a higher level abstraction and then wire them together. The abstractions themselves then do not know where their data comes from, nor where it goes.
+
Note that simple dependency injection or otherwise passing an object into another object doesn't remove the association between their respective classes. It only changes the relationship from composition to association, neither of which is allowed between peer classes. In other words, in ALA you are not allowed to know about a class in the same layer, not even its interface. Not even a base class. Instead you must use a much more abstract interface called a programming paradigm interface from a lower layer. The use of this type of interface means that the classes know nothing about the outside world. That's why we call the usage a port.

* *Composition*, *Aggregation*, *Realization*: Although the knowledge dependency relationship used in ALA can be implemented as a UML composition relationship (arrow with filled diamond), an Aggregation (arrow with unfilled diamond) or Realization (dashed arrow) the ALA knowledge dependency is more constrained. It must be instantiating a class, using objects of a class or interface, or implementing an interface in a lower, more abstract, layer. The composition, aggregation and realization relationships in ALA can go down by one or more layers, but never up or across within a layer.

* *Inheritance*: ALA doesn't need or use inheritance. It would break the abstraction of the (more abstract) base class in the lower layer. Instead we always use composition. 
+
By way of example, given the concepts of vehicle, car and truck, in conventional object oriented programming we may be tempted to create a base vehicle class in a lower layer, and implement car and truck in the higher layer. But we may then be tempted to implement things that _most_ vehicles have such as 4 wheels, and attempt to override that when we have an exception such as a vehicle with tracks. 
+
If we restrict ourselves to composition, we instead create multiple classes for common parts of vehicles in the lower layer, and just compose car, track and tank from them.

() common parts of the vehicle domain would be invented as their own abstractions in the lower layer, and then car and truck would be composed from instances of them. In other words, the word 'vehicle' we would take to mean a category or domain, not a part in itself. Now we may need to express the requirement to "drive the vehicle". In this case the car and truck would each implement a 'drive' interface, not be derived from a generic vehicle that is drivable. 

If there was justification to build a concrete generic drivable vehicle, it would be used from the upper layers using composition not inheritance. A real world example is more like a chassis concept. Variations would be handled by a configuration interface (the public interface), not overriding chassis components.

Inheritance is often used to provide a 'calling up the layers at run-time' mechanism by its use of virtual functions. In ALA, we do this with ordinary observer pattern (events in C#), or by passing in a method as a configuration (usually anonymously or as a lambda expression), or with the strategy pattern. 

* *Packages*: ALA does not use hierarchies or nesting. In other words, abstractions cannot be contained by other abstractions. Abstractions are never private. The reason they are never private is simple. An abstraction that is depended on should be more abstract than the abstraction using it. A more abstract abstraction needs to be public so it can be reused. ALA uses abstraction layers instead of encapsulation hierarchies. In ALA, packages would only be used as a distribution mechanism, not as part of the architecture for information hiding.
+
The word package means container. Packages are usually just a container of abstractions such as a library. We should not consider knowledge dependencies to be on the package because we can't generally learn a package. We should consider knowledge dependencies to be on the individual abstractions inside the package.
+
Let's consider the situation where a conventional package is a good abstraction in itself. Because it was implemented as a package, it's internal implementation is large (Facade pattern). Let's say our conventional package hides a lot of complex implementation and contains  abstractions that we are not interested in using in the rest of our application. For example it could be a compiler that we can invoke from our application. The thing is, if the compiler abstraction is written using ALA, it will use lots of useful abstractions for the domain of compilers and parsing. We still want those abstractions to be public for reuse. It's just that we don't want them particularly visible to the rest of our application, which is in a different domain. To solve this problem we should still make the abstractions used by the compiler abstraction public, but put them into a different DomainAbstractions folder and namespace. When we do this, we will want the DomainAbstractions folders to be qualified with the name of the domain, such as CompilerDomainAbstractions.

* *Namespaces*: While not part of the UML, we can discuss namespaces here in case you think of them in some way similar to packeages. In ALA, namespaces are used for the layers. For example we use namespaces such as Application, DomainAbstractions and ProgrammingParadigms. This allows unrelated abstractions in different layers to have the same name. The files that implement abstractions are put inside folders that have the same names as the namespaces.
+
Note that unlike packages, namespaces are not encapsulations. Namespaces only make names unique. One 3rd party tool I used to generate dependency graphs showed dependencies on namespaces as if namespaces were abstractions. This gave a completely misleading view of the true nature of the dependencies in the code. I had to write a custom query for the tool to show the actual dependencies on the abstractions inside the namespaces.


=== Abstraction layers

Because the target of a dependency must be more abstract, abstractions arrange themselves in discrete layers. This is what gives the architecture its name: Abstraction Layered Architecture.

Only a small number of layers are needed. Consider that we can construct the human body with just six layers: Atoms, Molecules, Proteins, Cells, Organs, Body. Probably need another two or three to build the human brain from neurons. Small applications generally use four. The layers are given standard names that describe their level of abstraction:

image::Layers.png[Layers.png, title="Abstraction layers", width=75%]


These layers are not fixed by ALA. But we tend to return to these ones in our experience so far. Following is discussion of each layer together with example code to see how everything works.



===== Application layer

In describing example layers, we start with example code. This code will build into a complete running application so no holes are left in understanding the code level mechanics of how everything works. The accompanying bullet points then explain the high level theory of why the code is organised the way it is. The code is available here:
https://github.com/johnspray74/Thermometer[https://github.com/johnspray74/Thermometer]


.Application\Thermometer.cs
[source,C#]
....
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Application
{
    class Thermometer
    {
        public static void Main()
        {
            Console.WriteLine("Wiring application");

            private ADCSimulator adc;

            adc = new ADCSimulator(channel: 2, period: 1000) { simulatedLevel = 400 }; <1>
            adc.WireIn(new LowPassFilter(strength: 10)) <2> <5> <6>
                .WireIn(new OffsetAndScale(offset: -200, scale: 0.2)) <3>
                .WireIn(new DisplayNumeric<double>(label: "Temperature") { units = "C"} ); <4>

            Console.WriteLine("Running application");
            adc.Run(); <7>

            Console.WriteLine("press any key to stop");
            Console.ReadKey();
        }
    }
}
....

To understand the code, you need to have knowledge of the abstraction concepts on which it depends. These are:

<1> ADCSimulator - domain abstraction simulates an analog to digital converter hardware peripheral. Has a single output port of type IDataFlow<int>

<2> LowPassFilter - domain abstraction - we already met this at the beginning of this chapter

<3> OffsetAndScale - domain abstraction - has a single input port and a single output port, both IDataFlow<double>. Adds a constant and Multiplies by another constant to transform data like a straight line on an x-y graph. 

<4> DisplayNumeric - domain abstraction - has one input port of type IDataFlow<double>. Displays the value on the console with label and optional units.

<5> WireIn - foundation abstraction - wires compatible ports of instances of abstractions by setting the private field in the first object that matches the interface implemented by the second object.

<6> These wirings are using the Dataflow programming paradigm. Dataflow is used by the ports of the domain abstractions and allows their instances to push data from one to the next at runtime if they are wired together. For dataflow programming, we default to pushing data through the system (from ADC to display). We use pulling when there is good reason, usually for  performance.

<7> The adc, which is the source of the data that gets pushed through the system, needs to be told to start running.

Once you have knowledge of these abstractions, notice that the application code is readabable by itself. It holds all knowledge about thermometers. 
That knowledge sits at the abstraction level of the requirements. It is highly cohesive - every line works with every other line to make a thermometer. It does none of the work itself - it just assembles and configures the needed worker objects.

The application layer is three things in one: The architecture design, the expression of requirements, and the executable. In conventional software development, these are three separate artefacts.

Execution typically occurs in two phases (similar to some monads). In the first phase the application wires together instances of abstractions. In the second phase the network of instances executes (which is what the finalizing call to Run starts).



===== Domain abstractions layer

At the beginning of this chapter we had an example of a domain abstraction, LowPassFilter. Here is another example:


.DomainAbstractions\OffsetAndScale.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary> <1>
    /// ALA domain abstraction
    /// Has one input port of type IDataflow and one output port of type IDataflow
    /// (both type double)
    /// Performs y = m(x+c) like operation where x is the input and y is the output
    /// If visualized as a straight line on an x,y graph, -c is the x axis intercept
    /// and m is the slope. 
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class OffsetAndScale : IDataFlow<double> // input <2>
    {
        public OffsetAndScale(double offset, double scale) <4>
        {
            this.offset = offset;
            this.scale = scale;
        }

        private double offset;
        private double scale;


        private IDataFlow<double> output; <3>

        void IDataFlow<double>.Push(double data) <5>
        {
            output.Push((data + offset) * scale);
        }
    }
}
....




Notes on the code:

<1> Important to comment what the abstraction concept is.

<2> The input port is the implemented interface.
+
In the application code in the previous section, an instance of LowPassFilter was wired to an instance of OffsetAndScale. When wired, the _output_ field of the LowPassFilter is set to the OffsetAndScale object, cast as the appropriate interface, in this case IDataFlow<double>.

<3> The output port _output_ is private so that it does not appear as a configuration to the layer above. It is set by WireIn or WireTo using reflection.


<4> It has two compulsory configuration parameters.

<5> When data is pushed into the input, it is transformed and pushed out of the output port.



For completeness, here are the other two domain abstractions that we used in the Thermometer application example:


.DomainAbstractions\DisplayNumber.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction
    /// Ouptuts incoming data to the console with a preceding label and optional units.
    /// Has one input port of type IDataFlow which can take int, float, double
    /// The label must be passed in the constructor.
    /// The units property may be used to set the units.
    /// fixPoint Property sets the number of decimal places.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class DisplayNumeric<T> : IDataFlow<T>
    {
        public DisplayNumeric(string label)
        {
            this.label = label;
        }

        public int fixPoints { get; set; } = 0;

        private string label;
        public string units { get; set; }


        void IDataFlow<T>.Push(T data)
        {
            double d = (double)Convert.ChangeType(data, typeof(double));
            Console.WriteLine($"{label}: { d.ToString($"F{fixPoints}") } {units}");
        }
    }
}
....




.DomainAbstractions\ADCSimulator.cs
[source,C#]
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction.
    /// Simulate a 10-bit ADC (analog to digital converter).
    /// Normally an ADC is a hardware peripheral, but here we just do a software
    /// simulation of one to use as a source of data for example applications.
    /// A real ADC driver would have properties for setting the channel and period.
    /// You would create one instance of this driver for each ADC channel.
    /// It would output raw data in adc counts.
    /// Since it is a 10 bit ADC, the adc counts are in the range 0-1023.
    /// We retain the channel although it is not used by the simulated version.
    /// The simulated version has two simulation properties, one to set the simulated
    /// ADC reading.
    /// and one to set the level of noise in the simulated readings.
    /// You need to understand the programming paradigm abstraction, IDataFlow,
    /// to understand this code.
    /// </summary>
    class ADCSimulator
    {
        public ADCSimulator(int channel, int period = 100)
        {
            this.channel = channel;
            this.period = period;
        }

        private int channel;  // unused on simulated ADC
        private int period;   // milliseconds
        public int simulatedLevel { get; set; } = 512; // 0 to 1023
        public int simulatedNoise { get; set; } = 0; // 0 to 1023

        private IDataFlow<int> output;

        public void Run()
        {
            RunAsyncCatch();
        }

        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
            }
        }

        Random randomNumberGenerator = new Random();

        public async Task RunAsync()
        {
            while (true)
            {
                // add a bit of noise to the adc readings
                int data = simulatedLevel + randomNumberGenerator.Next(simulatedNoise)
                            - simulatedNoise/2;
                if (data < 0) data = 0;
                if (data > 1023) data = 1023;
                output.Push(data);
                // throw new Exception("exception test");
                await Task.Delay(period);
            }
        }
    }
}
....



As can be seen in the above examples, the domain abstractions layer contains concepts that can be composed into applications. These are typically building blocks for I/O, data transformations, and persistent state, but many other types of abstractions are possible.

Some of these types of things may also be found in general language libraries but domain abstractions are more specific to the types of applications we want to express using them. They are specific to a domain, making them more expressive, but less reusable than general purpose language abstractions. They are still reusable both within a single application and by other applications in the same domain.

Another difference between ALA domain abstractions and typical library abstractions is the use of ports. This supports building functionality by simply composing instances of abstractions. While the composing code controls who will communicate with whom, it does not actually handle the data at run-time. The data moves directly between instances via the wired ports. 

A further difference between ALA domain abstractions and typical library abstractions is that when domain abstractions are composed, the meaning of composition can be a programming paradigm other than imperative. For example the application above uses a dataflow programming paradigm. Imperative is not usually a good programming paradigm for the expression of requirements, but it's all your basic language gives you (unless you are using language integrated monads, which also give you dataflow programming).

The domain abstractions layer and programming paradigms layer together are like a DSL (Domain Specific Language). We can think of domain abstractions as composable domain language elements and the programming paradigms as providing the grammar. 

It is an internal DSL because it uses the underlying language (_WireTo_ method, and _new_). This allows you to easily fall back on the greater flexibility of the underlying language when you need to. For example, you can pass lambda expressions as configuration properties to a domain abstraction. Or, you can pass a whole object of a class that you write in the application layer (which is the strategy pattern).

Conventional libraries generally contain good abstractions. What makes them good abstractions is that their designers don't know anything about the specific applications that will use them. Writing domain abstractions is best done in the same way. After the need for an abstraction is decided, pretend you don't know anything about the application, and are writing something to be useful, reusable and learnable as a new concept. Then they should not just be specific parts of a specific application.

As we said, abstractions know nothing of each other at design-time, yet can still communicate directly with one another at run-time. It is the responsibility of the code in the layer above that composes them to know the meaning of the data. It knows the meaning of the data even though it does not handle the data. For example, our application above knows that data going from the ADC to the LowPassFilter is raw adc values representing temperature, and what the values mean. It knows that the data passing between the LowPassFilter and the OffsetAndScale is sufficiently smoothed and slowed down for a stable display. It knows that the data passing from the OffsetAndScale to the display is in degrees celsius. All these pieces of knowledge are cohesive in the design of the thermometer, and so belong together inside the Thermometer abstraction. 


===== Programming paradigms layer

For the Thermometer example application above, we wired four instances of domain abstractions. That wiring used a single programming paradigm, _Dataflow_. Here is the interface for the dataflow programming paradigm: 

.IDataFlow.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IDataFlow<T>
    {
        void Push(T data);
    }
}
....

Programming paradigm interfaces are often this simple. Another example programming paradigm is _synchronous event driven_. The corresponding interface might be: 

.IEvent.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IEvent { void Execute(); }
}
....


Here is the interface for another common programming paradigm, the UI layout. In this programming paradigm, a parent UI element is wired to its contained child elements.


.IUI.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    interface IUI { UIElement GetUIElement(); }
}
....

The interface returns the .NET WPF element of the child. This allows domain abstractions to construct the UI using underlying WPF elements. In effect, UI domain abstractions are wired together in a similar way to XAML. Both have descriptive, tree structured syntax, but ALA is using the underlying C# language whereas XAML is using XML.

You can conceive other programming paradigms to give different meanings to composition of domain abstractions in such a way as to allow the easiest representation of typical requirements. For example, for implementing game scoring, I used a programming paradigm called _ConsistsOf_. For tennis, I used it to express that a match consists of a sets, a set consists of a games, and a game consists of a points. See the example project at the end of chapter four which uses it to implement tennis and bowling. Being able to compose instances of domain abstractions together with meanings that you define in the programming paradigms layer is powerful.

ALA is polyglot in programming paradigms. An application typically mixes a small set of different paradigms. Each provides a different meaning when the application wires two instances of domain abstractions together. Examples might be Dataflow, UI Layout, Event driven, State machine transition, Data schema entity relationship. Some may have variations such as pushing or pulling, or synchronous and asynchronous.

Programming paradigms control the way the application actually executes. Execution models such as synchronous vs asynchronous, push vs pull, and fan-out and fan-in wiring are discussed in Chapter four.

Programming paradigms provide the rules for the way instances of domain abstractions can be composed by the application. They are the grammar of the DSL.

Programming paradigms provide the mechanism of direct communication between instances of domain abstractions. They do this without the abstractions themselves knowing anything about each other. 

Through the use of programming paradigms, domain abstractions know nothing about each other at design-time, yet instances of them can communicate at run-time. Of course we could achieve this by making the application handle the run-time communications. The common example would be an application that calls one function which returns a result, and then calls another function passing the result to it. This would almost comply with ALA. The problem is we don't really want the application to be concerned with run-time communications. The application really just wants to concentrate on representing user stories by composing instances of domain abstractions. So we use a layer below the domain abstractions called programming paradigms. The programming paradigms allow domain abstractions to have compatible ports, which in turn allows them to communicate directly with one another at run-time. The design of the communications is in the Application layer, but the execution is in the domain abstractions and programming paradigms layers. 



===== Foundation layer

The foundation layer contains code used to support ALA programs in general.

A common pattern I use is a WireIn() and WireTo() extension methods in the foundation layer. The application layer uses them to wire together instances of Domain Abstractions using ports.

WireIn() and WireTo() are dependency injection methods.

WireTo(), uses reflection. It's not essential to use reflection for ALA. You could use dependency injection setters in every domain abstraction instead. You would need one setter per port on the left abstraction. You wouldn't use constructor dependency injection because sometimes wiring a port is optional. I prefer using the WireTo extension method because it allows domain abstractions to not need all these setters.

Here is minimal code for the WireTo method.



 Wiring.cs
[source,C#]
....
namespace Foundation
{
    public static class Wiring
    {
        /// WireTo is an extension method on the type object.
        /// Wires instances of classes that have ports by matching interfaces.
        /// Port name can be optionally provided for the A side.
        /// If object A has a private field of type interface,
        /// and object B implements that interface, 
        /// and the private field is not yet assigned,
        /// assigns B to the field in A.
        /// Uses reflection.
        /// Returns the left object for fluent style programming.
        public static T WireTo<T>(this T A, object B, string APortName = null)
        {
            // achieve the following via reflection
            // A.field = B; 
            // if 1) field is private 
            //    2) field type matches one of the implemented interfaces of B
            //    3) field is not yet assigned

            if (A == null) throw new ArgumentException("A is null "); <4>
            if (B == null) throw new ArgumentException("B is null ");

            bool wired = false;
            var BType = B.GetType(); <1>
            var AfieldInfos = A.GetType().GetFields(System.Reflection.BindingFlags.NonPublic 
                | System.Reflection.BindingFlags.Instance) 
                .Where(f => (APortName == null || f.Name == APortName)) // match portname if any
                .Where(f => f.GetValue(A) == null) // not yet assigned
            var BinterfaceTypes = BType.GetInterfaces().ToList(); // ToList to do the reflection once

            foreach (var AfieldInfo in AfieldInfos) <2>
            {
                var BimplementedInterface = BinterfaceTypes
                    .FirstOrDefault(interfaceType => AfieldInfo.FieldType == interfaceType);
                if (BimplementedInterface != null)  // there is a matching interface
                {
                    AfieldInfo.SetValue(A, B);  // do the wiring <3>
                    wired = true;
                    break;
                }
            }

            if (!wired) // throw exception <4>
            {
                var AinstanceName = A.GetType().GetProperties()
                    .FirstOrDefault(f => f.Name == "InstanceName")?.GetValue(A);
                var BinstanceName = B.GetType().GetProperties()
                    .FirstOrDefault(f => f.Name == "InstanceName")?.GetValue(B);

                if (APortName != null)
                {
                    // a specific port was specified - see if the port was already wired
                    var AfieldInfo = AfieldInfos.FirstOrDefault();
                    if (AfieldInfo?.GetValue(A) != null)
                        throw new Exception($"Port already wired  {A.GetType().Name}[{AinstanceName}].{APortName} to {BType.Name}[{BinstanceName}]"
                    );
                }
                throw new Exception($"Failed to wire {A.GetType().Name}[{AinstanceName}].\"{APortName}\" to {BType.Name}[{BinstanceName}]");
            }
            return A;
        }



        /// Same as WireTo, but returns the right object instead of the left object
        public static object WireIn<T>(this T A, object B, string APortName = null)
        {
            WireTo(A, B, APortName);
            return B;
        }
    }
}
....

<1> It first gets an IEnumerable of all the private fields in class A. If a port name is passed in, it must match. Then it gets a list of all the interfaces of class B.

<2> It iterates through the fields to find one that matches any of the interfaces of B.

<3> It sets the field in A pointing to B, cast as the interface type. 

<4> When there are errors in wiring code, it would be nice to get errors at compile-time. The WireTo extension method can't do that, but it does throw exceptions at wiring time when the application first starts. Since in ALA all wiring is generally done at this time, at least you wont have potential exceptions later during normal run-time. 

Four different exceptions may be thrown. 1) Object A (left object being wired) is null. 2) Object B (right object being wired) is null. 3) A specific A side port was specified, but it is already wired. 4) No matching A side port was found. 


Once again, slightly more complete code is available here:
https://github.com/johnspray74/Thermometer[https://github.com/johnspray74/Thermometer]



===== Extra layer for larger applications

If a single abstraction is used for the application, then as more and more user stories are added into it, it will eventually get too large for the ALA size constraint. Meanwhile, domain abstractions and programming paradigms are stable and do not generally grow larger with overall program size. They may increase in number, but it is the application that will go over the 500 line complexity limit.

ALA will need to be applied to the large application abstraction by adding a new layer below it. The requirements are likely already written in terms of abstractions which we call _features_ or _user stories_ or _use cases_. We can use these abstractions as the basis for the new layer. We call the layer "Features" or "UserStories". The application abstraction becomes a composition of features or user stories.

Let's extend the Thermometer example code we used above to have a new feature for measuring load. At the same time, let's introduce a features layer with the two features: temperature and loadcell.

I have deliberately retained a need for communication between the two features to show how features can also have ports and be wired together. 


====== Application layer


.Application\Application.cs
[source,C#]
....
using Features;
using Foundation;

namespace Application
{
    class Application
    {
        /// <summary>
        /// Instantiate two features: a temperature readout and a loadcel readout.
        /// Also wire the Temperature to the Loadcell for temperature compensation 
        /// </summary>
        public static void Main()
        {
            Console.WriteLine("Wiring application features");

            var temperature = new Temperature(); <1>
            var load = new LoadCell(); <1>

            temperature.WireTo(load); // for temperature compensation <2>

            Console.WriteLine("Running application");
            Console.WriteLine("press any key to stop");
            temperature.Run();
            load.Run();
            Console.ReadKey();
        }
    }

}
....

<1> The code instantiates two features for this particular application.

<2> The code wires together the feature to get temperatures sent to Loadcell at run-time. Feature abstractions can have ports. A common example of wiring between features would be to wire a feature instance's menu items to a _main menu_ feature.


====== Features layer

The Features layer contains independent features or user story abstractions. 

Each feature creates instances of domain abstractions, configures the instances with feature specific details, and connects them together as needed to express the feature or user story.

Here is the Thermometer application rewritten to be a Temperature feature:

.Features\Temperature.cs
[source,C#]
....
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Features
{
    /// <summary>
    /// Feature to coninuously measure temperature and periodically display it
    /// in degrees C on the console.
    /// Has an output port that outputs the temperature. 
    /// </summary>
    class Temperature
    {
        private IDataFlow<double> output; // temperature in celcius <1>

        private ADCSimulator adc;

        public Temperature()
        {
            const int adcLevel = 400;  // 40 C
            adc = new ADCSimulator(channel: 2, period: 1000) { simulatedLevel = adcLevel, simulatedNoise = 100 };
            adc.WireIn(new ChangeType<int, double>()) <2>
                .WireIn(new LowPassFilter(strength: 10, initialState: adcLevel))
                .WireIn(new OffsetAndScale(offset: -200, scale: 0.2)) // 200 adc counts is 0 C, 300 adc counts is 20 C
                .WireIn(new DataFlowFanout<double>()) <3> 
                .WireTo(new DisplayNumeric<double>(label: "Temperature") { units = "C"} ) <5>
                .WireTo(new DataFlowExternalPort<double>((d) => output?.Push(d))); <4>
        }


        public void Run()
        {
            adc.Run();
        }
    }
}
....

<1> The feature has an output port for temperature
+
The wiring itself is the same as it was in the Thermometer application except that three extra objects are used to make the dataflow wiring work. Their classes come from the Dataflow programming paradigm abstraction. These classes are:

<2> ChangeType: allows Dataflow ports of one type to be wired to Dataflow ports of a different type. In this case, the output of ADCSimlator is _int_ and the input of LowPassFilter is _double_.

<3> DataFlowFanout: A normal output port can only be wired once. DataFlowFanout allows you to wire to multiple places. In this case we wanted to wire the output of OffsetAndScale to both a DisplayNumeric and an external port.

<4> DataFlowExternalPort. We want to wire the output of the DataFlowFanout to the external port _output_. You might think you could just write .WireTo(output). The reason this doesn't work is that when the Temperature constructor runs, the code on the outside is instantiating a Temperature. That same external code would not have wired our _output_ port yet. It's value will be null at this time. Therefore we instead wire to a simple class that takes a function as its configuration. For the function we pass in a lambda expression that will push the data via the _output_ port.

<5> Note that WireTo is used to wire DataFlowFanout to multiple places. WireIn wires things in a chain. 

Here is the other feature used by our example application, the Loadcell.

.Features\Loadcell.cs
[source,C#]
....
using DomainAbstractions;
using ProgrammingParadigms;
using Foundation;

namespace Features
{
    /// <summary>
    /// Class:
    /// Feature to coninuously measure a load from a load cell and display it in kg on the console.
    /// Displays with one decimal place.
    /// Has temperature compensation for better accuracy (optionally feed temperature into the input port in degress C) 
    /// </summary>
    class LoadCell : IDataFlow<double> // input for temperature compensation <1>
    {
        private ADCSimulator adc;
        private DataFlowInitializer<double> defaultTemperature;
        private OffsetAndScale offsetAndScaleTemperature;

        /// <summary>
        /// Constructor:
        /// Feature to coninuously measure a load from a load cell and display it in kg /// on the console.
        /// Displays with one decimal place.
        /// Has temperature compensation for better accuracy (optionally feed temperature 
        /// into the input port in degress C) 
        /// </summary>
        public LoadCell()
        {
            // Wire an adc to an OffsetAndScale to an Add to a DislayNumeric.
            adc = new ADCSimulator(channel: 3, period: 500) { simulatedLevel = 200, simulatedNoise = 0 }; <2>
            var add = new Add(); <4>
            adc.WireIn(new ChangeType<int, double>())
                .WireIn(new OffsetAndScale(offset: 0, scale: 0.5)) <2>
                //.WireIn(new DataFlowDebugOutput<double>((s)=> System.Diagnostics.Debug.WriteLine(s))) <3>
                // .WireIn(new DataFlowDebugOutput<double>(Console.WriteLine)) <3>
                .WireIn(add)
                .WireTo(new DisplayNumeric<double>(label: "Load") { fixPoints = 1, units = "kg" } ); <2>

            // Wire the inut port for temperature to another OffsetAndScale to the other input of the Add.
            defaultTemperature = new DataFlowInitializer<double>(); <6>
            offsetAndScaleTemperature = new OffsetAndScale(offset: -20, scale: -0.1); // compensate -0.1 kg/C from 20 C <2>
            defaultTemperature.WireIn(offsetAndScaleTemperature) <7>
                .WireIn(new DataFlowConvert<double, Double2>((d)=>new Double2(d))) <5>
                .WireIn(add);

        }



        void IDataFlow<double>.Push(double data)
        {
            ((IDataFlow<double>)offsetAndScaleTemperature).Push(data); <7>
        }


        public void Run()
        {
            defaultTemperature.Push(20);  // in case no temperture is connected to the input port, set it to 20 C
            adc.Run();
        }
    }
}
....

<1> This time the feature has an input port for temperature, which is the implemented interface.

<2> Notice the reuse of several domain abstractions in this feature. The DisplayNumber abstraction is configured to display one decimal place.

<3> Debugging a dataflow can be done by inserting an object (decorator pattern) that outputs the values in the stream.

<4> A new domain abstraction called _Add_ is used. It has two IDataflow<double> inputs and a IDataFflow<double> output. We assign the Add to a local variable so that we can wire the second input later. Note that a C# class cannot implement the same interface twice (even though there is no reason why not). There are several ways we have used to work around this limitation. The one used here is to make one of the ports a Double2, a struct containing a double. This allows to have a double with a different type.

<5> To wire to the Double2 input port, we convert from double to Double2 using a DataFlowConvert<double, Double2>() abstraction. This abstraction can do any transformation on Dataflow, so is analogous to the Select() or Map() functions used in query languages.

<6> DataFlow initializer is a domain abstraction that can be used to initialize inputs of a dataflow in case no input arrives in time at run-time. In this case one of the two inputs to _Add_ may not arrive if the temperature input port is not connected to anything. We therefore want to initialize it with a default temperature of 20 C. 

<7> Note that it is not a problem to do fan-in wiring. Both defaultTemperature and the input port are connected to the input port of  offsetAndScaleTemperature.

For completeness, here is the code for the Add domain abstraction. Note that this abstraction is doing more than what a single + operator would. It is adding two dataflows.

.DomainAbstraction\Add.cs
[source,C#]
....
using System;
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA domain abstraction to add two numeric dataflows.
    /// Currently only supports doubles.
    /// Two input ports are implemented interfaces.
    /// One output port called "output".
    /// Both inputs must receive at least one data before output begins.
    /// Thereafter output occurs when either input receives data.
    /// One of the inputs is type Double2, which is a struct containing a double.
    /// This is a work around for can't implement the same interface twice.
    /// When wiring to the Double2 port, do it via an instance of DataFlowConvert like this:
    /// .WireIn(new DataFlowConvert<double, Double2>((d)=>new Double2(d))).WireIn(new Add());
    /// You need to understand the programming paradigm abstraction, IDataFlow, 
    /// to understand this code.
    /// </summary>
    class Add : IDataFlow<double>, IDataFlow<Double2> <1>
    {
        private IDataFlow<double> output; <2>

        private double? operand1; <3>
        private double? operand2; <3>

        void IDataFlow<double>.Push(double data) <4>
        {
            operand1 = data;
            if (operand2.HasValue)
            {
                output.Push(operand1.Value + operand2.Value);
            }
        }

        void IDataFlow<Double2>.Push(Double2 data) <5>
        {
            operand2 = data.Value;
            if (operand1.HasValue)
            {
                output.Push(operand1.Value + operand2.Value);
            }
        }
    }
    
    
    /// <summary>
    /// Wrap a double in a struct.
    /// We do this only to get a different type of double to effectively get multple inputs
    /// for the "Add" class because C# wont allow implementing the same interface
    /// twice (it should though).
    /// </summary>
    struct Double2
    {
        public Double2(double value) { this.value = value; }
        private readonly double value;
        public double Value { get { return value; } }
        public override string ToString() => $"{value}";
    }    
....

<1> Two input ports

<2> One output port

<3> For storing the last value received on each input. They are nullables so that we know when we have had input.

<4> Implement the first input port

<5> Implement the second input port










=== Folders, files, classes, objects, interfaces, functions

This is the second perspective on ALA. In this perspective we look at the implementation language elements and see how they are used in ALA applications.

==== folders and namespaces

If you see an ALA application, you will find three to five folders that correspond with abstraction layers (described in the previous section). For example:

* Application
* Features
* DomainAbstractions
* ProgrammingParadigms
* Foundation

Knowledge dependencies only go down these layers. So to understand the code inside files in the higher layers, you need to have knowledge of what all the files in lower layers do. There are no dependencies between files in any folder.

Namespaces exactly correspond with these folder names. Therefore we have namespaces called "Application", "DomainAbstractions", "ProgrammingParadigms", etc. This tells us which layer an abstraction comes from, and which folder it resides in. 

Namespaces also avoid naming conflicts between layers. They are not useful beyond that. Unfortunately, there is no convenient way of telling the compiler or the IDE to not 'see' classes, interfaces etc in other files in the same namespace or folder.

==== Files

Abstractions are implemented as files. Abstractions are often implemented as a single class, function, or interface, but sometimes an abstraction consists of a small cohesive group of them, with things like delegates, enums, or even variables. Internal to an abstraction, they interconnect with each other unconstrained. There are no dependency rules inside a file. The only constraint ALA makes is that the total must be small - of the order of 200-500 lines of code, or under the brain size limit. This applies to all abstractions, including the ones that make up the application itself in the top layer.

In time I hope languages catch up and give us visibility support for ALA abstraction. This would probably involve a new construct called _Abstraction{}_ to group the elements of an abstraction. It does not need a name. This construct replaces the use of a file that we are currently using as a stand-in. Anything public inside the Abstraction is only visible to code in higher layer abstractions, i.e. abstractions in higher namespaces. It is not visible in your own namespace, nor to those of lower layers. The compiler would need to know the namespace layering order. If we had this, we would have compiler checking for illegal dependencies. 



==== Objects

In ALA, abstractions are usually a single class. Instances of such abstractions are objects. It is the objects that get wired togther by their ports. Classes are the design artefacts that know nothing about one another. Objects are the run-time artefacts that communicate with one another at run-time.

==== Interfaces

Classes have a 'main interface', the constructors, and any public methods and properties. A class can also implement other interfaces. In ALA, a class's 'main interface' (it's constructors and public methods and properties) are only used to instantiate and configure the class from a higher layer. It is never used to actually use the class to do its work. This is effectively the ISP (interface segregation principle). The client who instantiates a class object is different from the classes whose objects will interact with it, so different interfaces are used. 

Only the higher layer with knowledge of the system has the relevant knowledge of what should be instantiated, how it should be configured, and how the instantiated objects should be composed together to make a system.

The 'main interface' of a class is 'owned' by the class and is specific to the class. This may sound like stating the obvious, since it is there to allow instantiation and configuration of said class. The thing is that no other interface implemented or required by the class can be 'owned' by the class. No other interface can be specific to the class. The class may not provide an interface designed specifically for it, not may it require an interface designed specifically for it. In other words, all other interfaces must be abstract and in a lower layer.

The idea that classes may not own any interface except the 'main interface' is critically important. If a class were to own another interface that is used for the class to do its work, then that interface would inherently have in its design knowledge about the class. This is true whether the interface is a provided interface (for other classes to use) or a required interface (for other classes to implement). Required interfaces are common for example in 'clean architecture'. They are illegal in ALA. 

The inherent knowledge about the class contained in 'owned' interfaces will cause coupling. A class using an interface provided by another class will have design knowledge of what that other class provides at the same abstraction level as itself. It will be written according to what is being provided. There will be a fixed arrangement between the two classes. Over time, this fixed arrangement will cause a blurring of their respective responsibilities.  

A class implementing an interface that is required by another class will have a similar problem. It will have design knowledge of what that other class requires at the same abstraction level as itself. It will be written according to what is required. There will be a fixed arrangement between the two classes. Over time, this fixed arrangement will cause a blurring of their respective responsibilities.  

Therefore, classes in ALA do not have association relationships. Instead they just have fields of the type of these more abstract interfaces or they implement these more abstract interfaces. We call both of these _ports_.

The abstract interfaces that we put in lower layers are obviously have to be be general. It can be hard to see how this could work, but it does. For example, interfaces often implement a set of four methods for CRUD operations (Create, Read, Update, Delete). The very existence of this acronym suggests an abstract interface. 

==== Composition with objects

An abstract interface in a lower layer makes it much easier to have multiple classes implement or require them. Objects of different classes can then be composed together in arbitrary ways, giving us the powerful principle of compositionality. (The meaning of a complex expression is determined by the meanings of the constituent expressions and the rules used to combine them.)

Abstract interfaces suggest general meanings for the ways we compose objects. They end up looking a lot like programming paradigms, which is why we call the layer ProgrammingParadigms.

Any given class will typically implement/accept more than one of these abstract interfaces. These are the called ports. When using dataflow they are I/O ports. We do not think of the objects that get wired to these ports as clients. The word client is best used for classes in a higher layer (that use the main interface). The classes of the objects to which an object is wired are just called peers.


==== Composition with functions

ALA can be applied to functional programming too. Abstractions are then obviously functions, and the same ALA relationship restriction applies - a function may only call a significantly more abstract function. The functions then form layers.

Where one function may have called a peer function in conventional code, now a higher layer function that has the system specific knowledge is needed to call the first function and then call the second function, in effect composing with functions. Parameters and return values are effectively port. If the first function called the second function in the middle rather than at the end, the second function will now need to be passed into it. The function parameter is also a port.

A higher layer function may call a series of lower layer functions, passing data from one to the next. We don't often need the data in the higher level function. All we are trying to do is compose functions. It clutters up the code something awful when we have to handle data without needing to use that data. So that's why we prefer to compose with objects with ports.

Monads also allow composition of functions without this cluttering. But they only support a dataflow type of programming paradigm. We want to compose using multiple ports on our abstractions using multiple programming paradigms. Objects with ports are a more straightforward way to think about this. Monads are objects under the covers, and this is part of the reason they are hard to understand (although eventually you get used to it). By composing with objects directly, it is clearer what is going on.

==== Readme file

There should be a readme file in the root folder that points to this website (or equivalent documentation) about ALA. In ALA, we are explicit about what knowledge is needed before a given piece of code can be understood (knowledge dependencies). To understand an ALA application, you need a basic understanding of ALA (from this chapter). So that's why there should be a readme file pointing here.




=== Executable expression of requirements

This is the third perspective of ALA. It is essentially the perspective of a DSL (domain specific language).

Writing software is re-expressing requirements in a different language. If that language is general purpose, we end up using a lot of symbols to express those requirements - many more than we would use in English. This is because in English we would use, or even invent terms in the domain to help us to be expressive and succinct. I'm not talking about customers or orders. I'm talking about general concepts for the UI, of data storage, or of certain events implied in our user stories.

Furthermore, if we are re-expressing requirements in a language that is essentially imperative (executes step by step instructions in computer time) it's going to be super awkward. Things like UI layout or asynchronous events don't map directly to imperative style. It's going to require a lot of cleverness to express them every signle time. 

Furthermore, let's say it takes 100 lines of English to state the requirements and 10000 lines of code to implement the requirements. Potentially all 10000 lines of code know about the requirements in some way. Each also knows about some computing detail like how to store data, how to do input/output, or how to schedule what its doing in real time. The details of requirements and the details of computing are mixed together. The expression of requirements is extremely verbose in such a design. 

ALA separates out the expression of requirements from computing details. It does this by first identifying the types of relationships inherent in requirements. These are not imperative calls in computer time. They are things like dataflows, events, and UI layouts. We invent programming paradigms for these. Then we invent types of things implied in the requirements with these relations. Things like UI elements, data transformations, data stores, and transactions. Now we have a domain specifc language. We compose instances of the thing types together using instances of our relationship types. The resulting expression of requirements is direct and succinct. 

In ALA the thing types are called _domain abstractions_. The relations are called _programming paradigms_. Each domain abstraction hides one generic piece of computing implementation. Each programming paradigm defines what the composition of two domain abstractions means. Programming paradigms hide an execution model for how the relationship will work in terms of underlying imperative execution.  

It is the top layer (or top two layers for larger applications) that describe all the details in the requirements (and nothing but the details of requirements.) All details of actual computing work go are the implementations inside the domain abstractions and programming paradigms. 

The amount of code that describes requirements is typically about 3-10% of the entire application. When requirements change, you only need to understand this 3-10%.

The percentage of code expressing requirements does depend on how many requirements there are. Because ALA emphasises the use of abstractions, and abstractions are reusable, an application with many requirements may have so much reuse that the percentage of code expressing requirements goes higher.

The expression of requirements in the top layer is executable. This could be compared with BDD (behavioural driven design) which is also expresses the requirements and is executable. But BDD only executes the tests. ALA goes one step further to make the expressed requirements the executable solution.

The executable description of requirements in the top layer is also the architecture or the design. (I do not make a distinction between architecture and design.) There is no separate artefact or documentation of the 'architecture', no model, no other "high level" design document. The one artefact expresses requirements, expresses the architectural design, and is the executable. So one source of truth for everything.



==== Polyglot programming paradigms

In this perspective of ALA, we view it as a vehicle for multi-paradigm programming.

Many higher level programming models are based on a single programming paradigm. Examples are the dataflow model, event-driven, actor (message passing) model, or ladder logic.

A given paradigm makes it easy to solve some problems but not others. Having a single programming paradigm makes the programming model pure and simple. But it's just plain awkward for certain aspects of typical problems. 

So ALA takes the approach that not only will we be able to compose using multiple programming paradigms, we do it it with the same wiring operators. This allows them to be easily intermixed in the same user story or feature, or in the same application diagram. Furthermore, creating and implementing a new programming paradigm is straightforward. 

In the end, we want to attain a certain level of expressiveness of composition. If we are too expressive we wont have enough versatility to vary our applications in the domain. If we don't have enough expressiveness, we will have to compose too many low level elements to get anything done.  

Some examples of programming paradigms that we use frequently are UI layouts, dataflow, schema relationships, state transitions. 

Each programming paradigm usually results in a type of port for the domain abstractions. Instances of two abstractions can then be wired by their compatible ports. The programming paradigm provides the meaning of that composition, and provides the execution model for that meaning to be carried out. 

There are other types of programming paradigms that don't need to use ports as well. For example, say you want a programming paradigm for style. You would create a Style concept abstraction in the programming paradigms folder. Then every UI domain abstraction would get its style properties from this abstraction. Then the application layer configures the style abstraction for a specific application, and all UI instances would take on that style. You would only use this method rather than ports if every ports would be connected to a single instance of something. If things are connected to one instance, that indicates that the instance itself can be an abstraction, and simply be put down a layer for everyone to access.

Some will disagree with the last paragraph as it effectively makes the style object a global. That's not great even if it is a good abstraction. Indeed if you want to say test a UI domain abstraction with styles, and do these tests in parallel, the global wont work. Or there may be leftover state in the global between different tests. Or we may want to override the style on one UI instance. If we don't want to use global instance of style, then we go back to ports. We then create an instance of style and wire every instance of every UI domain abstraction to this instance. To make such wiring easier, I have  WireMany operator. This extension method will look for a compatible  port on every instance of every domain abstraction.    




=== Diagrams

In this perspective, we view ALA as a vehicle for diagram oriented design.

We don't have to use diagrams in ALA. It only comes about because requirements typically contain a whole network of relationships. For example, UI elements have spacial relationships with one another. They have relationships with data. Data has relationships with storage (state which is expected to persist across user stories). Stored data has it's own inter-relationships. All have relationships with real-time events.

In conventional code, this network of relationships results in a network of dependencies across the modules of the code. These types of dependencies are used for run-time communications. Inverting these types of dependencies doesn't help. It's still a dependency that's only there for run-time communications. We don't like circular dependencies, but communications are often naturally circular. So we introduce still more indirections, obscuring the natural network even further.

The result is a big ball of mud. It consists of thousands of symbolic references. 'All files' searches are needed to find these references and unravel the network.
 
ALA elliiminates this network of dependencies and replaces them with ordinary lines of code that instantiate abstractions and wire them together. That code is placed inside the top application abstraction (or into a set of feature or user story abstractions). The code is cohesive because it represents in one place the network of relationships that make up a feature user story.

In this wiring code, the network nature of the inter-relationships within a user story between instances of domain abstractions becomes obvious. It can become clear that the best way to express it is a diagram.  ALA therefore uses diagrams quite often. These diagrams are, more or less, like static UML object diagrams. So in ALA, we throw away the UML class diagrams (relationships between abstractions), and use UML object diagrams instead (relationships between instances).

==== Diagrams vs text

In the trivial examples of composition that we already gave, we either used fluent style text for the wiring code drectly, or we manually translated a diagram into fluent style wiring code. You may wonder, why bother with diagrams? They require a tool. 

There is a bad meme in the software industry that diagrams and text are equivalent for representing software, They are far from equivalent. They each have different strengths and weaknesses. Using the wrong one will significantly increase the difficulty of reading it. 

The only reason I convert diagrams to fluent style text is because our examples are small and they have a mostly linear or shallow tree topology. I manually translate the diagrams to readable text to show how the diagrams execute.

Linear diagrams and shallow trees can better represented in text. Deep trees become hard to read because it results in too much indenting. For larger diagrams with arbitrary cross connections, using text requires a lot of 'symbolic connections' or labels to represent what would be anonymous lines on the diagram. These symbolic wirings make the code much harder to read as their number increases beyond a few connections. If you find yourself doing "all files searches" when reading code, you finding those connections, painstakingly one at a time. If you use a diagram, you just follow the lines.

An advantage of expressing the network in diagram form is that you don't have to give names to instances. You can leave them all anonymous if you want to. Sometimes you will give them names anyway as documentation. For example, if you have two grids implied in your requirements, you will want to give them names so you know which is which in the diagram.

Avoiding diagrams is like an electronics engineer avoiding a schematic, or an architect avoioding drawings. In conventional code, a network of relationships implied by the requirements is still in there. If we use text to represent it, it is much harder to read, even if we put it in one cohesive place. But what we actually do is even worse. We distribute that text throughout our modules, making it difficult to see. That is why conventional code typically becomes a mass of dependencies resembling a big ball of mud. Using such tricks as dependency inversion, indirections, or container style dependency injection makes the situation even worse. The network of relationships is still there, but now it is even more difficult to see. 

Sometimes programming with diagrams is called model driven software development. I prefer not to use the word 'model'. In the real world, models leave out details. Software models tend to leave out details too. ALA diagrams do not leave out details. All details from the requirements are represented, for example in the form of configuration of the instances. That no details are left out is why the diagram is also the executable.

The diagram is stored in the application layer folder. When a diagram is used for the internals of a feature or user story, it resides in the respective layer folder. 
When diagrams become large, they need two tools. One tool allows you to draw the diagram, and the other generates wiring code automatically. The generated code does not use fluent style - it is just a list of instantiations followed by a list of wirings between them. The wiring code generated from the diagram lives in a subfolder from where the diagram is, because it is not source code.

If manually generating code from a diagram, the diagram should always be changed first, then the code. There should be a readme explaining exactly what the generated code should look like.

Automatically generated code does not need to be readable except to the extent of finding where it doesn't accurately reflect the diagram.  




=== Composition vs decomposition methodologies

In this perspective, we look at software design methodology. Conventional wisdom is a decomposition approach. You decompose a system into modules or components. Those modules are further decomposed into submodules and so on. By contrast, ALA is a composition approach. It composes the system from instances of abstractions. Those abstractions are composed from instances of even more abstract abstractions. The difference is important as it results in a completely difefrent structure.

In the next chapter we will discuss in detail why ALA uses a 'composition' approach rather than a 'decomposition' approach. Here we describe the two different structures that result from these two approaches.

In the conventional approach, components tend to get more specific than the system because they are specific parts of it. It is a bit like jigsaw pieces to a jigsaw picture. The pieces are not reusable. The picture is not a separate entity - it is just the set of pieces, which have a rigid arrangement with each other. The picture cannot change without changing the pieces.

In the ALA approach, abstractions used to compose a system must be more abstract than the system. It is a bit like lego pieces to a specific lego creation. The pieces are reusable. The lego creation is a separate entity in itself - it is more than the set of pieces. The lego creation can change without changing the pieces.


==== Encapsulation hierarchy vs layers

Because a decomposed system tends to create modules that are specific to the system, these modules tend to be not reusable. They may be replaceable with modules that have the same interfaces, but not actually reusable. We tend to encapsulate such modules inside the system. Similarly with submodules, we encapsulate them inside their modules. This creates an encapsulation hierarchy. It is sometimes likened to a map in which we can zoom in for greater detail. 

This actually doesn't work for hiding information at design time. Because  the modules are specific and not abstractions, you will always have to zoom in for the details of the inner modules in order to understand the system. Encapsulation makes as much sense as hiding the picture on every individual piece of a jigsaw puzzle unless you zoom into it, then trying to see the big picture. 

The encapsulation may help to unclutter the IDE namespace at the system level, but it doesn't reduce how much you have to go inside the encapsulations to understand the system.

If the modules and submodules are abstractions, and those abstractions are more abstract than the modules that use them, then we don't have to zoom in. We can understand a system in terms of the abstractions it uses. 

Abstractions are reusable. So we explicitly do not want to encapsulate them inside something that uses them. We need them to be public for reuse. Instead of encapsulating them, we use abstraction layers. 


==== Primary separation

Decomposition tends to break up a system first according to these types of criteria:

* locations of physical machines or processors (e.g. tiers, services)
* computing problems (e.g. UI, business logic, data storage)
* business structure (Conway's law)

A system decomposed in this way will make features or user stories span the modules. This is bad. It forces us to create dependencies for communications within a feature or user story.

In ALA, features or user stories are obvious abstractions given to us by the requirements. As such we keep them together, even if they cross over these other boundaries. For example, if UI, business logic, and storage span three different machines, there is nothing stopping us coding or drawing a single diagram containing all the elements of the UI, business logic and storage for a user story. The elements will be instances of abstractions deployed on different machines, but that is a deployment detail. As long as the internal lines in the diagram represent asynchronous communications, the feature or user story will still work when deployed. Deployment time abstractions can insert the necessary middleware. No specific interfaces are needed between the elements on different machines because they are instances of abstractions that already have compatible asynchronous-ready ports. (We cover asynchronous ports in detail in chapter four.) 

The way the resulting code is organised will be completely different from a convention decomposition. The relationships that exist between conventional modules will disappear. They become cohesive lines of code inside a new abstraction representing the system. In fact that's all the system abstraction will need to do.


// TBD needs reviewing in light of new text above

===== contrasting the two structures


image::Slide8.jpg[Slide8.jpg, title="Decomposition into elements and their relations", align="center"]

The figure shows five conventional modules (or components) and their relations (as interactions). Study almost any piece of software, and this is what you will find (even if it supposedly adheres to the so-called layering pattern).

The structure generally can be viewed as 'clumping'. Like galaxies, certain areas have higher cohesion, and so go inside boxes. Other areas are more loosely coupled, and so are represented by lines between the boxes. The difference between high cohesion and loose coupling is only quantitative.

Software health in this type of architecture is effectively management of the resulting coupling between the cohesive clumps. Allocate code to boxes in such a way as to minimize coupling. This coupling management has two conflicting forces. One is the need to have interactions to make the modules work as a system. The other is to minimize the interactions to keep the modules as loosely coupled as possible. As maintenance proceeds, the number of interactions inevitably increases, and the interfaces get wider. Cohesion will reduce, and coupling will increase over time.

Various architectural styles are aimed at managing this conflict. Most notably:

* Layering pattern (break circular dependencies and replace them with indirections which are even worse.)
* Try to avoid both high fan-in and high fan-out on a single module
* Try to avoid dependencies on unstable interfaces
* MVC type patterns

Note that none of this 'dependency management' actually avoids design-time coupling. There will always be 'implicit coupling' in both directions between modules of a decomposed system, regardless of the dependencies. This is because the modules are the opposite of abstractions - specific parts designed to interact or collaborate to make a system. For example, a function of a decomposed system will tend to be written to do what its caller requires even if there is no explicit compile-time dependency on its caller. So circular coupling may be avoided at compile-time, but will still be present at design-time. That is why in the diagram above, couplings are drawn from the insides of each of the modules in both directions. This indicates that the code inside the modules has some inherent collaboration with the code inside other modules. To the compiler or a dependency graphing tool, the lines may appear to be layered, but this is not telling you the whole story of the design-time coupling.


===== The compose approach

When you use abstractions instead of modules, there is qualitative difference in how the structure is built. There are no  interactions, collaboration, or coupling between abstractions: 

image::Slide9.jpg[Slide9.jpg, title="Abstraction do not interact", align="center"]

The word 'modules' has been changed to the word 'abstractions'. All the dependencies are gone. And with them all their problems. You no longer have to worry about dependencies and all their management. The implicit coupling that we talked about earlier is also gone. The 'clumping' structure has become isolated boxes. Loose coupling has become zero coupling.

The obvious question now is how can the system work? Where do all the  interactions between elements that we had before go? The answer is they become normal code, completely contained inside one additional abstraction. This code composes instances of the abstractions to make a system:

image::Slide10.jpg[Slide10.jpg, title="Abstractions and composition of their instances", align="center"]

The code inside the new system abstraction does not involve dependencies _between_ abstractions. It uses dependencies _on_ abstractions. It's code that instantiates abstractions and wires them together via their (even more abstract) ports. Since interactions between the instances are implemented without dependencies between the abstractions, circular wiring is fine. In fact we should embrace it, because that is how the system works. 

This instantiation and wiring code is cohesive. It is _the_ code that has knowledge of the specific system. None of the code inside the abstractions knows about the specific system, only this new code.

We put the abstractions, A, B, C, D and E into a layer. The system abstraction goes in the layer above.

[TIP]
====
Software engineering should [red]#*not*# be about [red]#*managing coupling*#.

It should be about [green]#*inventing abstractions*#. 
====


=== cf Component based development

In this perspective, we compare ALA with components, component based software engineering (component based development), components and connectors.

When you read the intentions for components, they are meant to be reusable. Since reuse and abstraction go hand in hand, it should follow that components are abstractions. Furthermore, just as we do in ALA, they have ports to supposedly allow them to have run-time communications with one another without breaking them as abstractions.

That's the intentions. In practice, all the component diagrams I have seen fall far short of this ideal. The components themselves appear to be specific pieces of a specific system. Although they have ports to allow reuse, they are too specific to the system they are designed for to be reusable abstractions. There maybe exceptions of course, but components lack a fundamental rule that constrains components to be more abstract than the systems they are used in. 

The UML component diagram uses lollipops to represent the ports. At first this seems great because it looks like you should then be able to wire them up in arbitrary ways. But, at the port level, all the example component diagrams I have seen use interfaces that are specific to one or other of the connected components. In other words the components have a fixed arrangement with each other. This in turn encourages them to collaborate and have implicit coupling with each other. It is the jigsaw analogy. 

In ALA, you must have compositonality. This means the abstractions have no fixed arrangement. You have the capability to compose instances of abstractions in an infinite variety of ways. It is the lego analogy.

Component architecture does have one thing - the ability to sunstitute one component for another with the same interfaces. 


Components allow hierarchical composition by having sub-components, but I am not clear on what that means. Does it mean component instances or component types? Some implementations I have seen allow you to configure the visibility of a component type. This means that component _type_ can be completely contained inside another component type. This type of hierarchy is illegal in ALA because used components must be more abstract and therefore must be defined outside where they are public for reuse. Of course using instances of a component inside another component is the whole point of how we build up a system in either ALA or component driven development.



==== Components and connectors

One implementation model for components is so called _components and connectors_. The mechanics of components and connectors is that the lines drawn between components are connector objects. They contain a value, which is the 'data on the wire'. Thinking of the wire as being a variable with a value is quite a useful programming paradigm. It is also a relatively efficient execution model. The variable itself is a shared variable that isn't globally visible. Only the two instances of components that are wired together can ever see it. Senders need only set the value of the variable, and receivers need only read the variable.

When two compatible instances of components are composed or wired together using this programming paradigm, the implied connector object is created automatically and wired inbetween them.

The instances of the components must be active objects (somehow execute by themselves). 

Let's see how to create such a programming paradigm for ALA applications:




.Connector.cs
[source,C#]
....
namespace ProgrammingParadigms
{
    class Connector<T> : IOutput<T>, IInput<T> <1>
    {
        T data { get; set; } = default(T);
        T IOutput<T>.data { get => data; set => data = value; }
        T IInput<T>.data { get => data; }
    }


    public interface IOutput<T> <2>
    {
        T data { get; set; }
    }

    public interface IInput<T> <3>
    {
        T data { get; }
    }


    public static class StaticMethods
    {
        public static void Wire<T>(ref IOutput<T> Aport, ref IInput<T> Bport) <4>
        {
            Connector<T> connector = new Connector<T>();
            Aport = connector;
            Bport = connector;
        }
    }
}
....


<1> The connector type itself. Instances are to be wired between two instances of domain abstractions. 

<2> One domain abstraction must have a port implemented as a field of the IOutput interface.

<3> One domain abstraction must have a port implemented as a field of the IInput interface. 

<4> A method for wiring two instances of domain abstractions creates the connector for you, and then wires the two instances to it.


Let's create two domain abstractions to demonstrate the use of this programming paradigm. First a domain abstraction with an output port using this programming paradigm.


.NaturaNumbersTenPerSecond.cs
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction
    /// Demo class to send data via a connector
    /// </summary>
    class NaturaNumbersTenPerSecond
    {
        public IOutput<int> output; <1>


        public void Run() <3>
        {
            RunAsyncCatch();
        }


        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }


        public async Task RunAsync()
        {
            int data = 0;
            while (true)
            {
                data++;
                output.data = data; <2>
                await Task.Delay(100);
            }
        }
    }
}
....

<1> The output port

<2> Outputting data to the output port

<3> This domain abstraction is active, so we need a Run method to start it running. 

And another domain abstraction with an input port using this programming paradigm.



.ConsoleOutputEverySecond.cs
....
using ProgrammingParadigms;

namespace DomainAbstractions
{
    /// <summary>
    /// ALA Domain Abstraction
    /// Demo class to send data via a connector
    /// </summary>
    class ConsoleOutputEverySecond
    {
        public IInput<int> input; <1>


        public void Run()
        {
            RunAsyncCatch();
        }


        public async Task RunAsyncCatch()
        {
            // because we are the outermost async method, if we let exceptions go,
            // they will be lost
            try
            {
                await RunAsync();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        }


        public async Task RunAsync()
        {
            while (true)
            {
                Console.WriteLine(input.data); <2>
                await Task.Delay(1000);
            }
        }
    }
}
....

<1> The input port

<2> Inputting data from the input port


And finally an application to wire together instances of these domain abstractions:



Application.cs
....
using DomainAbstractions;
using static ProgrammingParadigms.StaticMethods;

namespace Application
{
    class Application
    {
        /// <summary>
        /// Application to demonstrate two active components running at different rates
        /// communicating using a connector.
        /// </summary>
        public static void Main()
        {
            NaturaNumbersTenPerSecond numbers = new NaturaNumbersTenPerSecond();
            ConsoleOutputEverySecond console = new ConsoleOutputEverySecond();
            Wire(ref numbers.output, ref console.input);
            
            numbers.Run();
            console.Run();
            Console.ReadKey();
        }
    }

}
....


// TBD read component and connector from chapter 7?








=== Real world analogies

==== Atoms and molecules

Here are two atom abstractions:

image:oxygen.png[Oxygen atom, 200, title="Oxygen atom"]
image:hydrogen.png[Hydrogen atom, 200, title="Hydrogen atom"]

Instances can be composed to make a molecule:

image:water_molecule.jpg[Water molecule, 300, title="Water molecule"]


If water was implemented in the same way we typically write software, there would be no water molecule per se; the oxygen atom would be modified to instantiate hydrogen atoms and interact with them. Even if dependency injection is used to avoid the instantiating, it is still unlikely that a water abstraction would be invented to do that, and there would still be the problem of the oxygen atom interacting with hydrogen's specific interface. The oxygen module still ends up with some implicit knowledge of hydrogen. And hydrogen probably ends up with some implicit knowledge of oxygen in providing what it needs. 

This implicit knowledge is represented by the following diagram. The relationship is shown coming from the inner parts of the modules to represent implicit knowledge of each other.

[plantuml,file="diagram-o-h.png"]
----
@startdot
digraph foo {
graph [rankdir=LR]
subgraph cluster_o { 
style="rounded"
margin="16"
Oxygen [style="setlinewidth(0)"]
}
subgraph cluster_h { 
style="rounded"
margin="16"
Hydrogen [style="setlinewidth(0)"]
}
edge [color=red]
Oxygen -> Hydrogen [dir="both", arrowhead="dot", arrowtail="dot"]
}
@enddot
----



While oxygen and hydrogen are modules, they are not abstractions because oxygen is implicitly tied to hydrogen and vice-versa. They can't be used as building blocks for any other molecules.

To keep oxygen as abstract as it is in the real world, an interface must be conceived that is even more abstract than oxygen or hydrogen. In the molecule world this is called a polar bond. It is one of the programming paradigms of molecules. Its execution model at run-time is the sharing of an electron.

The corresponding software would look like this:


image::Slide15.jpg[Slide15.jpg, title="", align="center"]

The water molecule has a "uses instances of" relationship with the two atoms, and the atoms have a "uses instance of" relationship with the even more abstract polar bond abstraction. Polar bond is an example of an 'abstract interface'.



==== Lego

The second real world analogy is Lego. Shown in the image below is the same three layers we had above for molecules, atoms and bonds.

image::Slide16.jpg[Slide16.jpg, title="", align="center"]

The domain abstractions are the various Lego pieces, instances of which can be assembled together to make specific creations. Lego pieces themselves have instances of an abstract interface, which is the stud and tube. This is a programming paradigm. There is a second abstract interface, the axle and hole. These programming paradigms have an 'execution model' at run-time. The execution of the stud and tube programming paradigm is to hold structural integrity. The execution of the axle and hole programming paradigm is rotation.

===== Conventional code analogy

If Lego is a good analogy for ALA, then what would be a good analogy for conventional code? 

It's an upside down jigsaw puzzle.

image::jigsaw.jpg[jigsaw.png, title="Conventional code is built like a jigsaw puzzle", width=75%]

The pieces are modules, and the interlocking shapes are the interfaces. The picture is the application or system.

Like the interlocking shapes, interfaces tend to be specific to pairs of modules. They may nominally belong to one module or the other, but the complimentary one bends to that interface, and vice versa. They have one rigid structure for how they fit together. The fixed relationship between modules tends to cause collaboration and coupling between them, and this tends to get worse over time as new features or user stories are added. 

The jigsaw puzzle is upside down because there is no view of the complete picture. You are allowed to pick up one piece at a time and look at the part of the picture that's on the other side. This is the equivalent of opening one module and reading the code inside it. By doing this repeatedly for many adjacent modules, you can start to get an idea of how part of the bigger system works. But, you have to keep the pieces of picture in your head, because there is no explicit view of it.

A jigsaw is all in one layer. The big picture, interfaces and pieces all exist in that one layer as a single information entity. ALA has at least three layers of information. Firstly, the general ways that pieces can be combined is an information entity in the lower layer. The building block types exist the next higher layyer. And particular arrangment of instances of building blocks is a separate information entity in a higher layer. 

Essentially ALA, like Lego, has the property of compositionality. Conventional code modules, like jigsaw pieces, generally do not.


==== Electronic schematic

The third real world analogy comes from electronics. The abstractions are electronic parts, instances of which can be composed as a schematic diagram:  

image::Slide17.jpg[Slide17.jpg, title="", align="center"]

In this domain, we have at least two abstract interfaces as programming paradigms, one for digital logic signals and one for analog signals. Their execution model at run-time is continuous-time voltage levels.


==== A clock

Our forth and final real world analogy is a clock. In this diagram, we show the process of composition of abstractions to make a new abstraction. The process is a circle because instances of the new abstraction can themselves be used to make still more specific abstractions. Each time around the circle adds one layer to the abstraction layering.

image::Slide18.jpg[Slide18.jpg, title="", align="center"]

Let's go round the circle once. We start with abstract parts such as cog wheels and hands. Instances of these have abstract interfaces as programming paradigms. Their execution models allow them to interact at run-time, such as spinning on axles and meshing teeth. The next step is to instantiate some of these abstractions and configure them. For example, configure the size and number of teeth of the cog wheels. Next comes the composition step, where they are assembled. Finally we have a new abstraction, the clock. Instances of clocks can in turn be used to compose other things such as scheduling things during your day. Because you have now created the abstraction _clock_ you don't have to think about cog wheels when thinking about how to meet someone at a certain time.

There are many other instances of this pattern in the real world, and in nature. In fact everything appears to be actually composed in this way. At least that's the way we understand and make sense of the world - in terms of abstractions, which are in composition layers.


---

=== Example Project - Coffee machine

Robert Martin posed an interesting pedagogical sized embedded system problem about a coffee maker in his book Agile Software Development: Principles, Patterns and Practices. The original chapter can be found by searching for Heuristics and Coffee. 

Although I agreed with Martin that his students' 'object oriented' solutions were hideous, I did not like his worked solution either. Although he had claimed to use abstractions, they were actually collaborating modules, just with abstract sounding names. So you had to read all the code to understand any of it. I wanted to know if ALA would tame the problem into a solution as succinct as the requirements. Because this is the first ever ALA project I did, some of the more refined ALA conventions, patterns and methods are not used here. But the fundamental constrains are met, and the result is spectacularly simple compared to Martin's solution.

Martin's worked solution to this problem uses decomposition into three modules that collaborate or interact with one another. The ALA solution follows the opposite philosophy. It has three abstractions. They come from the specification - a button with an indicator light, a warmer plate, and a boiler. They do not collaborate or interact with one another. As domain abstractions, they also know nothing about the coffee machine. The coffee machine is then constructed (as another abstraction in the top layer) that makes use of the three domain abstractions. 

This example uses different execution models from the UI and dataflow ones that we use a lot in other examples. Here we use some simple, yet quite interesting electronic-signal-like execution models that use a simple main-loop polling type implementation, just as Robert Martin's original solution also had.

Reading an ALA application requires first knowing the pre-requisite knowledge you need from lower layer abstractions. So before presenting the application, let's first familiarise ourselves with the abstractions we need from the domain layer, and the Programming Paradigms layer.

==== Domain abstractions layer

Here are the three domain abstractions:

image::Coffee%20Maker%20Domain%20Components.vsd.jpg[Coffee Maker Domain Components.vsd.jpg, title="Coffee maker domain abstractions", link=images/Coffee%20Maker%20Domain%20Components.vsd.jpg]

Take a moment to look at these three abstractions:

-- The UI has a lamp you can control, and a push button which outputs an event (should have been two separate abstractions).

-- There is a WarmerPlate. It tells you whether or not a container is on the warmer plate, and whether or not it is empty. It controls its own heater. 

-- There is a  Boiler. It can be turned on or off. It will tell you when it is empty of water. And you can stop water flow instantly with a steam release valve. It will turn its own heater off if it runs out of water, or the valve is opened. 

That's all there is to know about the three domain abstractions.

==== Programming Paradigms layer

We have three programming paradigms

-- live dataflow (works like an electronic circuit)

-- events

-- simple state machine

The API for the Programming Paradigms layer is described in the key on the right of the diagram below. It gives you all the knowledge from this layer to be able to read the diagram. So, for example, a solid line is a dataflow; the rounded box is state with the states enumerated inside it.

The details of how to turn the diagram into code is explained in a project document, also provided in the Programming Paradigms layer.


==== Application layer

Now that we have understood the knowledge dependencies in all lower layers, we can read the diagram that resides in the top layer, the application layer:



image::Coffee%20Maker%20Dataflow%20diagram.vsd.jpg[CoffeeMaker Dataflow diagram, title="Coffee maker solution", link=images/Coffee%20Maker%20Dataflow%20diagram.vsd.jpg]

The diagram to the left is the application itself. Instances of the three domain abstractions, UI, Boiler and Warmer plate are shown as boxes.

Follow me now as we go through the user stories by looking at the lines on the diagram:

* When the UI push button is pressed, we set the state to Brewing, provided the Boiler is not empty and the pot is on the Warmerplate. (On the diagram, it looks like a NOT operator is missing on the Empty signal from the boiler to the AND gate.)

* When the state is brewing, it turns on the boiler, and coffee making starts.

* If someone takes the pot off, the valve is opened to momentarily release pressure from the boiling water, which stops the water flow. 

* When the boiler becomes empty, the state is set to Brewed. When the state is Brewed, the light in the UI is on.

* When the coffee pot is replaced empty, the state goes back to the idle state where we began.

That's all there is to reading this application. The code for the coffee machine can be read and understood in about one minute. Compare that with reading other solutions to the coffee machine problem.

Note that the paragraph above is pretty much a restatement of the requirements in English. It could have been the requirements. The amount of information in the English form (or the diagram form) is about the same, thus the Domain Abstractions gave us the correct level of expressiveness. Further confirmation of this is if the level of expressiveness allows us to modify it.

For example, say a requirement was added that a coin device was to enable the machine to be used. The coin device is an abstraction that provides an output when a coin is given, and has a reset input. Looking at the diagram, and being able to reason about its operation so easily, you can see that the coin device's output would intercept the Pushbutton using another instance of an AND gate. And to reset the coin device, you could use the boiler empty output event.

==== Execution

To make it actually execute, we apply the manual procedure documented in Execution models.doc. This document is in the Programming Paradigms layer. It will generate these 6 lines of code:

    if (userInterface.Button && warmerPlate.PotOnPlate && !boiler.Empty) { state = Brewing; } userInterface.Button = false;
    boiler.OpenSteamReleaseValve = !warmerPlate.PotOnPlate;
    boiler.On = state==Brewing;
    if (boiler.Empty && !prevBoilerEmpty) { state = Brewed; } prevBoilerEmpty = boiler.Empty;
    if (warmerPlate.PotEmpty && !prevPotEmpty) { state = Idle; } prevPotEmpty = warmerPlate.PotEmpty;
    userInterface.LightOn = state==Brewed;
 

There is a one-to-one correspondence between the lines in the diagram and the lines in the code. 

As you can see, the execution model is a simple one. The 6 lines of code are continually executed in a loop. This execution model is effective and appropriate for this small application.

The 6 lines of code can be built into a complete program shown below:

....
 #ifndef _COFFEE_MAKER_H_
 #define _COFFEE_MAKER_H_
 // Coffee Maker domain abstraction
 #include "CoffeeMakerAPI.h"  // original hardware abstraction supplied by hardware engineers
 // Knowledge dependencies :
 // "PolledDataFlowProgrammingParadigm.doc" -- explains how to hand compile a dataflow diagram of this type to C code
 // Following are 3 Domain abstractions that the application has knowledge dependencies on
 
 
 
 #include "UserInterface.h"
 #include "Boiler.h"
 #include "WarmerPlate.h"
 
 
 
 class CoffeeMaker
 {
 private:
    enum {Idle, Brewing, Brewed} state;
    Boiler boiler;
    UserInterface userInterface;
    WarmerPlate warmerPlate;
    bool prevBoilerEmpty, prevPotEmpty;
    void _Poll();
 public:
    CoffeeMaker()
        : state(Idle), prevBoilerEmpty(boiler.Empty), prevPotEmpty(warmerPlate.PotEmpty)
    {}
    void Poll();
 };
 #endif //_COFFEE_MAKER_H_
....
 
....
 // CoffeeMaker.c
 // This is not source code, it is code hand compiled from the CoffeeMaker application diagram
 #include "CoffeeMaker.h"
 
 void CoffeeMaker::_Poll() <1>
 {
    if (userInterface.Button && warmerPlate.PotOnPlate && !boiler.Empty) { state = Brewing; } userInterface.Button = false;
    boiler.OpenSteamReleaseValve = !warmerPlate.PotOnPlate;
    boiler.On = state==Brewing;
    if (boiler.Empty && !prevBoilerEmpty) { state = Brewed; } prevBoilerEmpty = boiler.Empty;
    if (warmerPlate.PotEmpty && !prevPotEmpty) { state = Idle; } prevPotEmpty = warmerPlate.PotEmpty;
    userInterface.LightOn = state==Brewed;
 }
 
 
 
 void CoffeeMaker::Poll()
 {
    // get inputs processed
    userInterface.Poll();
    boiler.Poll();
    warmerPlate.Poll();
    // run application
    _Poll();
    // get outputs processed
    userInterface.Poll();
    boiler.Poll();
 }
....

<1>  The 6 lines of code appear in the "CoffeeMaker::_Poll()" function.


If you are using a diagram as we are in this solution, you always change the diagram first when the requirements change. It provides the expressiveness needed to see the applications requirements represented in a clear, concise and cohesive way. There the logic can be reasoned with. It is not documentation, it is the source code representation of the requirements, and executable, both important aspects of ALA.

The next step is to implement the three abstractions. These are straightforward using the same execution model as was used for the application, so are not shown here.

The resulting application passes all of Martin's original acceptance tests plus a number of additional tests of behaviour gleaned from his original text.


// TBD why not use #defines?
